{
  "__html": "<h1>Best Practice | DolphinScheduler Python API CI/CD</h1>\n<p><img src=\"https://miro.medium.com/max/720/1*YtC8CaZqJ5y-dTtoLhviNg.webp\" alt=\"\"></p>\n<p>Written by Zhong Jiajie, Apache DolphinScheduler PMC</p>\n<h1>DolphinScheduler and Python API Introduction</h1>\n<p>Apache DolphinScheduler is a distributed and extensible workflow scheduler platform with powerful DAG visual interfaces. It helps users easier to build and maintain workflow on any scale.\n<img src=\"/img/media/16714202226727/16714203387608.jpg\" alt=\"\">\nIn order to meet the needs of all users that have different preferences in the same team, DolphinScheduler provides a variety of ways to create workflows. The most popular way is through the web UI, which creates workflows with simple drag and drop and allows non-engineers to create. If you are an engineer and prefer to define workflows programmatically, you may consider using its Python API or YAML file definition to create it.</p>\n<p>PyDolphinScheduler is a Python API for Apache DolphinScheduler, which allows you to define your workflow by Python code, aka workflow-as-codes. You can write python code in any editor you like, just like using other python libraries, to create DolphinScheduler‚Äôs users, environment, project, and workflow. For more practice examples, you can refer to [<a href=\"https://medium.com/codex/dolphinscheduler-can-schedule-workflows-with-python-scripts-a882fdd2d862\">DolphinScheduler can schedule workflows with Python scripts!</a>] for more detail.</p>\n<h1>A Simple Python API Example</h1>\n<p>As an out-of-box tool, Python API has an example named tutorial, which includes the basic concept and minimum codes to create and run our very first workflows, you can see more detailed code at https://github.com/apache/dolphinscheduler-sdk-python/blob/main/src/pydolphinscheduler/examples/tutorial.py. The core concept of DolphinScheduler and its Python API is DAG, also calls workflow in Python API. More figuratively, it is the whole picture shown in the following figure. Each DAG contains multiple nodes and connections between nodes, like the node named A, B, C and etc, and the link between. In Python API, the task represents the node of DAG and the dependence for the connections between nodes.\n<img src=\"/img/media/16714202226727/16714204071793.jpg\" alt=\"\"></p>\n<h1>How to Trigger Python API Workflow</h1>\n<h2>Single One</h2>\n<p>So we already know the basic concept of Python API and we already have an example of it, then how can we trigger it and make it run and get our job done? To make it more pythonic, you can run it just like other Python scripts, via the terminal with a simple command.</p>\n<pre><code>python tutorial.py\n</code></pre>\n<p>The PyDolphinScheduler will help you set all the things and create a new workflow, after that you can see the new one in DolphinScheduler web UI.</p>\n<h2>Multiple Workflows</h2>\n<p>What if I have multiple files with multiple workflows, how can I trigger them? Yeah, you may already think about it, you can trigger them one by one, just like we trigger the single one. we can be done with</p>\n<pre><code>python workflow1.py\npython workflow2.py\npython workflow3.py\n...\npython workflowN.py\n</code></pre>\n<p>We can add all the above commands into a single bash script, after that, all we need is to execute the bash script</p>\n<pre><code>bash &lt;bash-script-contain-all&gt;\n</code></pre>\n<p>It is useful, but when some workflows add or delete, we have to change the bash script too, which means we must consider changing our code synchronously. Otherwise, the bash script will fail, or some of our new workflows will not be triggered.</p>\n<p>The way to fix it is simple, we can dynamic detection the Python script in specific directories, and then pass the existing script to the Python interpreter, and we can change our script like</p>\n<pre><code>for file in $(find . -name &quot;*.py&quot;); do\n    python &quot;$file&quot;\ndone\n</code></pre>\n<p>And that is, that is the final script we trigger all our DolphinScheduler Python API workflows on any scale. But it is a little different in reality, I mean that nearly no one deploys production workflows by manually triggering. So the next step we will talk about how to trigger our workflow in CI</p>\n<h1>Trigger in GitHub Action</h1>\n<p>In this section, we will trigger our workflows via CI, we use GitHub Action as an example and believe other CI tool is almost the same.</p>\n<h1>What is GitHub Action</h1>\n<p>GitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want. With the popularity of GitHub and the open-source project movement, GitHub Action is very popular currently. You can see more detail in the GitHub Action document. And here is a hello world of GitHub Action:</p>\n<pre><code>name: GitHub Actions Demo\non:\n  push:\n    branches:\n      - main\njobs:\n  hello-world:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run my very first GitHub Actions\n        run: echo &quot;üéâ Hello World.&quot;\n</code></pre>\n<p>You can save it as a YAML file and put it in your project with the path</p>\n<p><code>.github/workflows/hello.yaml</code> to tell GitHub what you ask her to do. After that, each time you have a commit and push it to the branch named main, our config file named <code>hello.yaml</code> will be trigged, and it will do nothing but one, execute the bash command and echo ‚Äúüéâ Hello World.‚Äù to the GitHub Actions console.</p>\n<h1>Combine GitHub Actions to Trigger Multiple Workflows</h1>\n<p>In the above example, you may have already realized that GitHub Actions can run bash commands. And our workflows batch trigger script is also a bash script. To get triggered through GitHub Actions, we may change the command in our GitHub Actions example.</p>\n<pre><code>name: Execute Workflows\non:    \n  push:\n    branches:\n      - main\njobs:\n  execute:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v3\n      - name: Execute\n        run: |\n          for file in $(find . -name &quot;*.py&quot;); do\n            python &quot;$file&quot;\n          done\n</code></pre>\n<p>It can only trigger and deploy workflows to GitHub Actions running hosts. Our DolphinScheduler cluster runs on the self-host server or could service like AWS instead of GitHub Actions, so we have to tell the bash script to submit our code to the DolphinScheduler cluster instead of the GitHub Actions servers. Fortunately, DolphinScheduler Python API provides a user-friendly configuration change in three ways. I recommend you change it via bash to change environment variables during the GitHub Actions which is simply by</p>\n<pre><code># Modify Java Gateway Address\nexport PYDS_JAVA_GATEWAY_ADDRESS=&quot;&lt;YOUR-STATIC-IP-RUN-DOLPHINSCHEDULER-API-SERVER&gt;&quot;\nexport PYDS_JAVA_GATEWAY_PORT=&quot;&lt;PORT-RUN-DOLPHINSCHEDULER-API-SERVER&gt;&quot;\n</code></pre>\n<p>GitHub Actions support <code>env</code> syntax in the YAML file, which you can see more detail in github-actions: environment-variables, and we can now change our GitHub Actions config to</p>\n<pre><code>name: Execute Workflows\non:\n  push:\n    branches:\n      - main\njobs:\n  execute:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v3\n      - name: Execute\n        env:\n          PYDS_JAVA_GATEWAY_ADDRESS: &lt;YOUR-STATIC-IP-RUN-DOLPHINSCHEDULER-API-SERVER&gt;\n          PYDS_JAVA_GATEWAY_PORT: &lt;PORT-RUN-DOLPHINSCHEDULER-API-SERVER&gt; \n        run: |\n          for file in $(find . -name &quot;*.py&quot;); do\n            python &quot;$file&quot;\n          done\n</code></pre>\n<p>Therefore, each time our main branch has new commits, whether it is generated by merging PR or pushed from locally, it will trigger and deploy all of our workflows defined in DolphinScheduler Python API, to where your DolphinScheduler cluster deployed.</p>\n<p>In the not released version, we add a new mechanism token for authentication to DolphinScheduler Python API, which means in the next version we have to add a token when we try to connect from Python API to DolphinScheduler, see https://github.com/apache/dolphinscheduler-sdk-python/pull/13 for more detail. Also, we highly recommend our users turn on the token authentication to make our connection safe. Just like other configurations, the token can also change via environment variables by bash„ÄÇ</p>\n<p>But how to trigger from GitHub Actions when we enabled and turn on the token? In this case, we have to use GitHub Encrypted secrets for help. You can follow the step motion in the link to create your very first safety secret to your repository and remember the name of your secrets. And then use it in the GitHub Actions config</p>\n<pre><code>name: Execute Workflows\non:\n  push:\n    branches:\n      - main\njobs:\n  execute:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v3\n      - name: Execute\n        env:\n          PYDS_JAVA_GATEWAY_ADDRESS: &lt;YOUR-STATIC-IP-RUN-DOLPHINSCHEDULER-API-SERVER&gt;\n          PYDS_JAVA_GATEWAY_PORT: &lt;PORT-RUN-DOLPHINSCHEDULER-API-SERVER&gt;\n          PYDS_JAVA_GATEWAY_AUTH_TOKEN: ${{ secrets.YOUR-SECRET-NAME }} \n        run: |\n          for file in $(find . -name &quot;*.py&quot;); do\n            python &quot;$file&quot;\n          done\n</code></pre>\n<p>SeeÔºü That is not complex, it is like using ordinary environment variables in GitHub Actions. And that is all we need to do about deploying workflows from GitHub Actions.</p>\n<h1>About CI</h1>\n<p>DolphinScheduler Python API script is a Python script, so it‚Äôs CI for Python language which may include black, Pylint, flake8, sort, autoflake and etc. If you choose to use Python API to create and maintain workflow instead of via web UI. I believe you already have personally preferred tools for code format and style check. I decide to talk about CI after then CD because it optional section. If you have your favorite, you can just use it and skip this section, but if you do not have one, I may share what I prefer to use and also Python API lint.</p>\n<p>First of all, I prefer using pre-commit, it will run each time when Git is committed, it is useful due to I can detect some easy but often overlooked detail before I push the code to remote. pre-commit needs a config file and I would like to share what Python API uses for itself code-style and lint code, you can see more detail at https://github.com/apache/dolphinscheduler-sdk-python/blob/main/.pre-commit-config.yaml</p>\n<pre><code class=\"language-default_stages:\">default_language_version:\n  # force all python hooks to run python3\n  python: python3\nrepos:\n  # Python API Hooks\n  - repo: https://github.com/pycqa/isort\n    rev: 5.10.1\n    hooks:\n      - id: isort\n        name: isort (python)\n  - repo: https://github.com/psf/black\n    rev: 22.3.0\n    hooks:\n      - id: black\n  - repo: https://github.com/pycqa/flake8\n    rev: 4.0.1\n    hooks:\n      - id: flake8\n        additional_dependencies: [\n          'flake8-docstrings&gt;=1.6',\n          'flake8-black&gt;=0.2',\n        ]\n        # pre-commit run in the root, so we have to point out the full path of configuration\n        args: [\n          --config,\n          .flake8\n        ]\n  - repo: https://github.com/pycqa/autoflake\n    rev: v1.4\n    hooks:\n      - id: autoflake\n        args: [\n          --remove-all-unused-imports,\n          --ignore-init-module-imports,\n          --in-place\n        ]\n</code></pre>\n<p>It does not run complex checks, all of them are easy to know, and to keep pre-commit can be done as soon as possible. The detail is:</p>\n<ul>\n<li>isort: Sort Python imports automatically</li>\n<li>black: Formatter Python code automatically</li>\n<li>autoflake: Removes unused imports and unused variables as reported by pyflakes automatically</li>\n<li>flake8: Detect other code and documentation</li>\n</ul>\n<p>And pre-commit is for the local check, you can also run it in your GitHub Actions by adding a new job before the existing job named execute</p>\n<pre><code class=\"language-name:\">on:\n  push:\n    branches:\n      - main\n  pull_request:\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v3\n      - name: Install Dependencies\n        run: |\n          python -m pip install --upgrade pre-commit\n      - name: lint\n        run: |\n          pre-commit install\n\t\t  pre-commit run --all-files\n  execute:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push'\n    needs: lint\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v3\n      - name: Execute\n        env:\n          PYDS_JAVA_GATEWAY_ADDRESS: &lt;YOUR-STATIC-IP-RUN-DOLPHINSCHEDULER-API-SERVER&gt;\n          PYDS_JAVA_GATEWAY_PORT: &lt;PORT-RUN-DOLPHINSCHEDULER-API-SERVER&gt;\n          PYDS_JAVA_GATEWAY_AUTH_TOKEN: ${{ secrets.YOUR-SECRET-NAME }} \n        run: |\n          for file in $(find . -name &quot;*.py&quot;); do\n            python &quot;$file&quot;\n          done\n</code></pre>\n<p>Some of you may notice that besides adding a new job, we also add <code>pull_request</code> node under <code>on</code> and <code>if</code> node under <code>execute</code> job. Because code lint check should test both push and pull requests event, but we only want to execute workflow when there is a new commit to branch main. If we make execute workflow for the pull requests event, each commit to pull requests will be executed and deployed to our production environment, even though the pull requests are not accessed or not prepared to merge. So we must set a condition to execute the workflow.</p>\n<p>Recap</p>\n<ul>\n<li>We show what DolphinScheduler and its Python API, and GitHub Actions are, How to create our very first workflow via DolphinScheduler Python API, and the first workflow in GitHub Actions.</li>\n<li>Then we show how to create DolphinScheduler Python API‚Äôs CI/CD base on GitHub Actions step by step.</li>\n<li>Finally, we create a GitHub Actions to detect code style, and auto lint our DolphinScheduler Python API‚Äôs workflow code.</li>\n</ul>\n",
  "time": "2022-12-16",
  "author": "Leonard Nie",
  "title": "DolphinScheduler Python API CI/CD",
  "type": "tech",
  "label": "Tech Sharing"
}