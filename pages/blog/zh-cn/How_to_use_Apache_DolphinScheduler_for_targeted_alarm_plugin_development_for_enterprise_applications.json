{
  "__html": "<p>在Apache DolphinScheduler的2.0.1版本 加入了插件化架构改进，将任务、告警组件、数据源、资源存储、注册中心等都将被设计为扩展点，以此来提高 Apache DolphinScheduler 本身的灵活性和友好性。在企业级应用中根据不同公司的告警需求可能各有不同，针对性的告警插件开发可以很好的解决这一痛点。</p>\n<p><strong>当前版本：3.1.2</strong></p>\n<h2>告警插件开发</h2>\n<p>先来看下alert目录的结构</p>\n<p><img src=\"/img/2024-01-19/1.png\" alt=\"\"></p>\n<ul>\n<li>dolphinscheduler-alert-api</li>\n<li>该模块是 ALERT SPI 的核心模块，该模块定义了告警插件扩展的接口以及一些基础代码，其中 AlertChannel 和 AlertChannelFactory 是告警插件开发需要实现的接口类</li>\n<li>dolphinscheduler-alert-plugins</li>\n<li>该模块包含了官方提供的告警插件，目前我们已经支持数十种插件，如 Email、DingTalk、Script等</li>\n<li>dolphinscheduler-alert-server</li>\n<li>告警服务模块,主要功能包括注册告警插件,Netty告警消息发送等</li>\n</ul>\n<p>本文以官方的http告警插件为例讲解如何进行插件开发</p>\n<ul>\n<li>首先明确需求,http告警插件需要通过http发送请求,发送请求首先需要确定哪些参数.在 <code>HttpAlertConstants</code> 可以看到有定义一些相关参数</li>\n</ul>\n<pre><code>package org.apache.dolphinscheduler.plugin.alert.http;\npublic final class HttpAlertConstants {\n    public static final String URL = &quot;$t('url')&quot;;\n\n    public static final String NAME_URL = &quot;url&quot;;\n\n    public static final String HEADER_PARAMS = &quot;$t('headerParams')&quot;;\n\n    public static final String NAME_HEADER_PARAMS = &quot;headerParams&quot;;\n\n...........................省略多余代码\n\n    private HttpAlertConstants() {\n        throw new UnsupportedOperationException(&quot;This is a utility class and cannot be instantiated&quot;);\n    }\n}\n</code></pre>\n<ul>\n<li>对应此处告警实例需要填写的参数</li>\n</ul>\n<p><img src=\"/img/2024-01-19/2.png\" alt=\"\"></p>\n<p>其中 $t('url') 样式的参数可以通过编辑</p>\n<blockquote>\n<p>dolphinscheduler-ui/src/locales/zh_CN/security.ts</p>\n</blockquote>\n<p>添加对应的参数,前端收到后会自动替换,同样的英文字典也需要替换,不然切换英文时会报错</p>\n<ul>\n<li>在<code>HttpAlertChannelFactory</code>需要实现<code>AlertChannelFactory</code>并实现它的方法<code>name</code>,<code>params</code>和<code>create</code>。其中<code>InputParam.newBuilder</code>的第一个参数是显示的值,第二个参数是参数名，这里用我们前面在<code>MailParamsConstants</code>写好的常量。所有参数写好后添加到<code>paramsList</code>后返回</li>\n</ul>\n<pre><code>@AutoService(AlertChannelFactory.class)\npublic final class HttpAlertChannelFactory implements AlertChannelFactory {\n    @Override\n    public String name() {\n        return &quot;Http&quot;;\n    }\n    @Override\n    public List&lt;PluginParams&gt; params() {\n        InputParam url = InputParam.newBuilder(HttpAlertConstants.NAME_URL, HttpAlertConstants.URL)\n                                   .setPlaceholder(&quot;input request URL&quot;)\n                                   .addValidate(Validate.newBuilder()\n                                                        .setRequired(true)\n                                                        .build())\n                                   .build();\n        InputParam headerParams = InputParam.newBuilder(HttpAlertConstants.NAME_HEADER_PARAMS, HttpAlertConstants.HEADER_PARAMS)\n                                            .setPlaceholder(&quot;input request headers as JSON format &quot;)\n                                            .addValidate(Validate.newBuilder()\n                                                                 .setRequired(true)\n                                                                 .build())\n                                            .build();\n        InputParam bodyParams = InputParam.newBuilder(HttpAlertConstants.NAME_BODY_PARAMS, HttpAlertConstants.BODY_PARAMS)\n                                          .setPlaceholder(&quot;input request body as JSON format &quot;)\n                                          .addValidate(Validate.newBuilder()\n                                                               .setRequired(false)\n                                                               .build())\n                                          .build();\n...........................省略多余代码\n        return Arrays.asList(url, requestType, headerParams, bodyParams, contentField);\n    }\n    @Override\n    public AlertChannel create() {\n        return new HttpAlertChannel();\n    }\n}\n</code></pre>\n<ul>\n<li>在<code>HttpAlertChannel</code>需要实现<code>AlertChannel</code>并实现<code>process</code>方法,其中<code>alertInfo.getAlertData().getAlertParams()</code>可以拿到在创建告警实例时填写的参数,在此处编写相关代码发送请求后,需要返回<code>AlertResult</code>对象用来标记请求发送or失败</li>\n</ul>\n<pre><code>public final class HttpAlertChannel implements AlertChannel {\n    @Override\n    public AlertResult process(AlertInfo alertInfo) {\n        AlertData alertData = alertInfo.getAlertData();\n        Map&lt;String, String&gt; paramsMap = alertInfo.getAlertParams();\n        if (null == paramsMap) {\n            return new AlertResult(&quot;false&quot;, &quot;http params is null&quot;);\n        }\n        return new HttpSender(paramsMap).send(alertData.getContent());\n    }\n}\n</code></pre>\n<p>至此插件开发就完成的,是不是很简单：）设计优秀架构合理的代码就应该是这样优雅高效解耦合.\n完成以上开发后,启动告警服务,就可以在添加告警实例时选择对应的插件了</p>\n<p><img src=\"/img/2024-01-19/3.png\" alt=\"\"></p>\n<h2>源码解读</h2>\n<p>在启动告警服务时,可以在日志看到有注册告警插件的信息</p>\n<p><img src=\"/img/2024-01-19/4.png\" alt=\"\"></p>\n<p>以此为切入口来探索插件实现的相关代码</p>\n<ul>\n<li>在dolphinscheduler-alert-server的<code>AlertPluginManager</code>的 installPlugin 方法可以看到注册告警插件的内容,这里先获取所有实现了<code>AlertChannelFactory.class</code>的类,遍历后获取<code>AlertChannel</code>的实例,添加到数据库和<code>channelKeyedById</code>Map</li>\n</ul>\n<pre><code>    private final Map&lt;Integer, AlertChannel&gt; channelKeyedById = new HashMap&lt;&gt;();\n    \n    @EventListener\n    public void installPlugin(ApplicationReadyEvent readyEvent) {\n        PrioritySPIFactory&lt;AlertChannelFactory&gt; prioritySPIFactory = new PrioritySPIFactory&lt;&gt;(AlertChannelFactory.class);\n        for (Map.Entry&lt;String, AlertChannelFactory&gt; entry : prioritySPIFactory.getSPIMap().entrySet()) {\n            String name = entry.getKey();\n            AlertChannelFactory factory = entry.getValue();\n            logger.info(&quot;Registering alert plugin: {} - {}&quot;, name, factory.getClass());\n            final AlertChannel alertChannel = factory.create();\n            logger.info(&quot;Registered alert plugin: {} - {}&quot;, name, factory.getClass());\n            final List&lt;PluginParams&gt; params = new ArrayList&lt;&gt;(factory.params());\n            params.add(0, warningTypeParams);\n            final String paramsJson = PluginParamsTransfer.transferParamsToJson(params);\n            final PluginDefine pluginDefine = new PluginDefine(name, PluginType.ALERT.getDesc(), paramsJson);\n            final int id = pluginDao.addOrUpdatePluginDefine(pluginDefine);\n            channelKeyedById.put(id, alertChannel);\n        }\n    }\n</code></pre>\n<ul>\n<li>完成插件的开发和注册后,需要有个轮询线程来遍历查询需要发送的消息和完成发送的动作,在<code>AlertSenderService</code>的<code>run</code>方法完成了这些</li>\n</ul>\n<pre><code>@Override\npublic void run() {\n    logger.info(&quot;alert sender started&quot;);\n    while (!ServerLifeCycleManager.isStopped()) {\n        try {\n            List&lt;Alert&gt; alerts = alertDao.listPendingAlerts();\n            AlertServerMetrics.registerPendingAlertGauge(alerts::size);\n            this.send(alerts);\n            ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS * 5L);\n        } catch (Exception e) {\n            logger.error(&quot;alert sender thread error&quot;, e);\n        }\n    }\n}\n</code></pre>\n<ul>\n<li>关键方法是<code>this.send(alerts)</code>,这里遍历<code>Alert</code>后获取告警插件的实例集合,在 <code>this.alertResultHandler(instance, alertData)</code>传入插件实例对象和告警参数,最后更新这条告警消息的状态</li>\n</ul>\n<pre><code>public void send(List&lt;Alert&gt; alerts) {\n    for (Alert alert : alerts) {\n        // get alert group from alert\n        int alertId = Optional.ofNullable(alert.getId()).orElse(0);\n        int alertGroupId = Optional.ofNullable(alert.getAlertGroupId()).orElse(0);\n        List&lt;AlertPluginInstance&gt; alertInstanceList = alertDao.listInstanceByAlertGroupId(alertGroupId);\n        if (CollectionUtils.isEmpty(alertInstanceList)) {\n            logger.error(&quot;send alert msg fail,no bind plugin instance.&quot;);\n            List&lt;AlertResult&gt; alertResults = Lists.newArrayList(new AlertResult(&quot;false&quot;,\n                    &quot;no bind plugin instance&quot;));\n            alertDao.updateAlert(AlertStatus.EXECUTION_FAILURE, JSONUtils.toJsonString(alertResults), alertId);\n            continue;\n        }\n        AlertData alertData = AlertData.builder()\n                .id(alertId)\n                .content(alert.getContent())\n                .log(alert.getLog())\n                .title(alert.getTitle())\n                .warnType(alert.getWarningType().getCode())\n                .alertType(alert.getAlertType().getCode())\n                .build();\n\n        int sendSuccessCount = 0;\n        List&lt;AlertResult&gt; alertResults = new ArrayList&lt;&gt;();\n        for (AlertPluginInstance instance : alertInstanceList) {\n            AlertResult alertResult = this.alertResultHandler(instance, alertData);\n            if (alertResult != null) {\n                AlertStatus sendStatus = Boolean.parseBoolean(String.valueOf(alertResult.getStatus()))\n                        ? AlertStatus.EXECUTION_SUCCESS\n                        : AlertStatus.EXECUTION_FAILURE;\n                alertDao.addAlertSendStatus(sendStatus, JSONUtils.toJsonString(alertResult), alertId,\n                        instance.getId());\n                if (sendStatus.equals(AlertStatus.EXECUTION_SUCCESS)) {\n                    sendSuccessCount++;\n                    AlertServerMetrics.incAlertSuccessCount();\n                } else {\n                    AlertServerMetrics.incAlertFailCount();\n                }\n                alertResults.add(alertResult);\n            }\n        }\n        AlertStatus alertStatus = AlertStatus.EXECUTION_SUCCESS;\n        if (sendSuccessCount == 0) {\n            alertStatus = AlertStatus.EXECUTION_FAILURE;\n        } else if (sendSuccessCount &lt; alertInstanceList.size()) {\n            alertStatus = AlertStatus.EXECUTION_PARTIAL_SUCCESS;\n        }\n        alertDao.updateAlert(alertStatus, JSONUtils.toJsonString(alertResults), alertId);\n    }\n}\n</code></pre>\n<ul>\n<li>在<code>alertResultHandler</code>用<code>alertPluginManager.getAlertChannel(instance.getPluginDefineId())</code>获取<code>AlertChannel</code>实例.还记得前面注册告警插件时往<code>channelKeyedById</code>里put的<code>AlertChannel</code>实例的动作吗?</li>\n</ul>\n<pre><code>public Optional&lt;AlertChannel&gt; getAlertChannel(int id) {\n    return Optional.ofNullable(channelKeyedById.get(id));\n}\n</code></pre>\n<ul>\n<li>然后构建<code>AlertInfo</code>对象,通过<code>CompletableFuture.supplyAsync()</code>来异步回调执行<code>alertChannel.process(alertInfo)</code>,用<code>future.get()</code>获得回调执行返回的<code>AlertResult</code>再return</li>\n</ul>\n<pre><code>private @Nullable AlertResult alertResultHandler(AlertPluginInstance instance, AlertData alertData) {\n    String pluginInstanceName = instance.getInstanceName();\n    int pluginDefineId = instance.getPluginDefineId();\n    Optional&lt;AlertChannel&gt; alertChannelOptional = alertPluginManager.getAlertChannel(instance.getPluginDefineId());\n    if (!alertChannelOptional.isPresent()) {\n        String message = String.format(&quot;Alert Plugin %s send error: the channel doesn't exist, pluginDefineId: %s&quot;,\n                pluginInstanceName,\n                pluginDefineId);\n        logger.error(&quot;Alert Plugin {} send error : not found plugin {}&quot;, pluginInstanceName, pluginDefineId);\n        return new AlertResult(&quot;false&quot;, message);\n    }\n    AlertChannel alertChannel = alertChannelOptional.get();\n\n    Map&lt;String, String&gt; paramsMap = JSONUtils.toMap(instance.getPluginInstanceParams());\n    String instanceWarnType = WarningType.ALL.getDescp();\n\n    if (paramsMap != null) {\n        instanceWarnType = paramsMap.getOrDefault(AlertConstants.NAME_WARNING_TYPE, WarningType.ALL.getDescp());\n    }\n\n    WarningType warningType = WarningType.of(instanceWarnType);\n\n    if (warningType == null) {\n        String message = String.format(&quot;Alert Plugin %s send error : plugin warnType is null&quot;, pluginInstanceName);\n        logger.error(&quot;Alert Plugin {} send error : plugin warnType is null&quot;, pluginInstanceName);\n        return new AlertResult(&quot;false&quot;, message);\n    }\n\n    boolean sendWarning = false;\n    switch (warningType) {\n        case ALL:\n            sendWarning = true;\n            break;\n        case SUCCESS:\n            if (alertData.getWarnType() == WarningType.SUCCESS.getCode()) {\n                sendWarning = true;\n            }\n            break;\n        case FAILURE:\n            if (alertData.getWarnType() == WarningType.FAILURE.getCode()) {\n                sendWarning = true;\n            }\n            break;\n        default:\n    }\n\n    if (!sendWarning) {\n        logger.info(\n                &quot;Alert Plugin {} send ignore warning type not match: plugin warning type is {}, alert data warning type is {}&quot;,\n                pluginInstanceName, warningType.getCode(), alertData.getWarnType());\n        return null;\n    }\n\n    AlertInfo alertInfo = AlertInfo.builder()\n            .alertData(alertData)\n            .alertParams(paramsMap)\n            .alertPluginInstanceId(instance.getId())\n            .build();\n    int waitTimeout = alertConfig.getWaitTimeout();\n    try {\n        AlertResult alertResult;\n        if (waitTimeout &lt;= 0) {\n            if (alertData.getAlertType() == AlertType.CLOSE_ALERT.getCode()) {\n                alertResult = alertChannel.closeAlert(alertInfo);\n            } else {\n                alertResult = alertChannel.process(alertInfo);\n            }\n        } else {\n            CompletableFuture&lt;AlertResult&gt; future;\n            if (alertData.getAlertType() == AlertType.CLOSE_ALERT.getCode()) {\n                future = CompletableFuture.supplyAsync(() -&gt; alertChannel.closeAlert(alertInfo));\n            } else {\n                future = CompletableFuture.supplyAsync(() -&gt; alertChannel.process(alertInfo));\n            }\n            alertResult = future.get(waitTimeout, TimeUnit.MILLISECONDS);\n        }\n        if (alertResult == null) {\n            throw new RuntimeException(&quot;Alert result cannot be null&quot;);\n        }\n        return alertResult;\n    } catch (InterruptedException e) {\n        logger.error(&quot;send alert error alert data id :{},&quot;, alertData.getId(), e);\n        Thread.currentThread().interrupt();\n        return new AlertResult(&quot;false&quot;, e.getMessage());\n    } catch (Exception e) {\n        logger.error(&quot;send alert error alert data id :{},&quot;, alertData.getId(), e);\n        return new AlertResult(&quot;false&quot;, e.getMessage());\n    }\n}\n</code></pre>\n<p>综上描述，可以画出注册插件和发送消息的时序图</p>\n<p><img src=\"/img/2024-01-19/5.png\" alt=\"\"></p>\n<p>以上就是告警插件的主要实现代码,是不是发现源码看下来也没有发现多高深和复杂：）所以多看看源码吧,以后你也可以写出这样优秀的开源软件来贡献开源</p>\n<p>参考连接</p>\n<blockquote>\n<p><a href=\"https://github.com/apache/dolphinscheduler/issues/3049\">[Feature] Alert Plugin Design · Issue #3049 · apache/dolphinscheduler (github.com)</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://dolphinscheduler.apache.org/zh-cn/docs/latest/user_doc/contribute/backend/spi/alert.html\">alert (apache.org)</a></p>\n</blockquote>\n",
  "time": "2024-01-19",
  "author": "刘宇星",
  "title": "企业级应用如何用 Apache DolphinScheduler 有针对性地进行告警插件开发？",
  "type": "tutorial",
  "label": "教程"
}