{
  "filename": "masterserver-code-analysis.md",
  "__html": "<p>这一篇主要讲解的是dolphinscheduler的master部分的源码，从主类MasterServer开始，从启动到运行，master主要做了以下三件事情</p>\n<ul>\n<li>Zookeeper 节点初始化</li>\n<li>构建并提交工作流实例，跟踪运行状态</li>\n<li>监控其他MasterServer和WorkerServer的健康状态并容错</li>\n<li>维系心跳</li>\n</ul>\n<pre><code>@PostConstruct\npublic void run(){\n        //详情见1.Zookeeper初始化\n        zkMasterClient.init(); \n        //详情见2.MasterSchedulerThread线程\n        masterSchedulerService = ThreadUtils.newDaemonSingleThreadExecutor(&quot;Master-Scheduler-Thread&quot;);\n        //详情见3.heartBeatThread线程\n        heartbeatMasterService = ThreadUtils.newDaemonThreadScheduledExecutor(&quot;Master-Main-Thread&quot;,Constants.DEFAULT_MASTER_HEARTBEAT_THREAD_NUM);\n}\n</code></pre>\n<h1>1. Zookeeper初始化</h1>\n<p>创建DS在Zookeeper的相关节点，并判断是否对系统做failover，恢复异常的工作流实例和任务实例。</p>\n<ul>\n<li>用于master的failover /dolphinscheduler/lock/failover/master</li>\n<li>系统节点，保存master和worker的心跳信息 /dolphinscheduler/masters; /dolphinscheduler/workers；/dolphinscheduler/dead-servers</li>\n</ul>\n<pre><code>public void init(){\n\tlogger.info(&quot;initialize master client...&quot;);\n\tthis.initDao();\n\tInterProcessMutex mutex = null;\n\ttry {\n\t    //创建分布式锁节点，用于master节点的failover \n\t\tString znodeLock = getMasterStartUpLockPath();\n\t\tmutex = new InterProcessMutex(zkClient, znodeLock);\n\t\tmutex.acquire();\n\t\t// 在ZK中初始化系统节点，\n\t\tthis.initSystemZNode();\n\t\t// 向ZK的/masters节点注册当前的master信息\n\t\tthis.registerMaster();\n\t\t// 通过监听Zookeeper临时节点变化来进行容错处理（如果活跃的master只有自身一个，则进行failover）\n\t\tif (getActiveMasterNum() == 1) { \n\t\t\tfailoverWorker(null, true);  //恢复任务实例 详情见1.1.\n\t\t\tfailoverMaster(null);   //恢复工作流实例 详情见1.2.\n\t\t}\n\t}catch (Exception e){\n\t\tlogger.error(&quot;master start up  exception&quot;,e); \n\t}finally {\n\t\treleaseMutex(mutex);\n\t}\n}\n</code></pre>\n<h2>1.1. failoverWorker 恢复任务实例</h2>\n<pre><code>private void failoverWorker(String workerHost, boolean needCheckWorkerAlive) throws Exception {\n   logger.info(&quot;start worker[{}] failover ...&quot;, workerHost);\n\n   List&lt;TaskInstance&gt; needFailoverTaskInstanceList = processService.queryNeedFailoverTaskInstances(workerHost);\n   for(TaskInstance taskInstance : needFailoverTaskInstanceList){\n      if(needCheckWorkerAlive){\n         if(!checkTaskInstanceNeedFailover(taskInstance)){\n             //不需要failover的两种情况\n             // 1.任务详情中不存在host信息\n             //2.任务在ZK中存在，则判断启动时间是否小于worker启动时间，小于则不用failover\n            continue;\n               }\n      }\n\n      ProcessInstance instance = processService.findProcessInstanceDetailById(taskInstance.getProcessInstanceId());\n      if(instance!=null){\n         taskInstance.setProcessInstance(instance);\n      }\n      // 如果任务中有yarn的任务则杀掉，kill的方式，日志中用正则匹配containId的格式，获取containID，用yarn命令kill。\n      ProcessUtils.killYarnJob(taskInstance);\n      //把任务的状态从“running”改为“need failover”\n      taskInstance.setState(ExecutionStatus.NEED_FAULT_TOLERANCE);\n      processService.saveTaskInstance(taskInstance);\n   }\n   logger.info(&quot;end worker[{}] failover ...&quot;, workerHost);\n}\n</code></pre>\n<h2>1.2. failoverMaster 恢复工作流实例</h2>\n<pre><code>private void failoverMaster(String masterHost) {\n   logger.info(&quot;start master failover ...&quot;);\n  //获取需要failover的工作流实例\n   List&lt;ProcessInstance&gt; needFailoverProcessInstanceList = processService.queryNeedFailoverProcessInstances(masterHost);\n   \n   for(ProcessInstance processInstance : needFailoverProcessInstanceList){\n       // 1.更新工作流实例的host为null\n       // 2.写入 t_ds_commond 表一条恢复工作流实例的命令\n      processService.processNeedFailoverProcessInstances(processInstance);\n   }\n\n   logger.info(&quot;master failover end&quot;);\n}\n</code></pre>\n<h1>2. MasterSchedulerThread 线程</h1>\n<p>该线程主要对command进行解析生成工作流实例</p>\n<pre><code>public void run() {\n    logger.info(&quot;master scheduler start successfully...&quot;);\n    while (Stopper.isRunning()){\n\n        // process instance\n        ProcessInstance processInstance = null;\n\n        InterProcessMutex mutex = null;\n        try {\n\n            boolean runCheckFlag = OSUtils.checkResource(masterConfig.getMasterMaxCpuloadAvg(), masterConfig.getMasterReservedMemory());\n            if(!runCheckFlag) {\n                Thread.sleep(Constants.SLEEP_TIME_MILLIS);\n                continue;\n            }\n            if (zkMasterClient.getZkClient().getState() == CuratorFrameworkState.STARTED) {\n\n                //创建分布式锁 /dolphinscheduler/lock/masters\n                String znodeLock = zkMasterClient.getMasterLockPath();\n\n                mutex = new InterProcessMutex(zkMasterClient.getZkClient(), znodeLock);\n                mutex.acquire();\n\n                ThreadPoolExecutor poolExecutor = (ThreadPoolExecutor) masterExecService;\n                int activeCount = poolExecutor.getActiveCount();\n                // 需要确保实例构建存储过程和command数据从表中删除的过程在一个事务中\n                Command command = processService.findOneCommand();\n                if (command != null) {\n                    logger.info(&quot;find one command: id: {}, type: {}&quot;, command.getId(),command.getCommandType());\n\n                    try{\n                        // handleCommand将commond解析成processInstance 详情见2.1\n                        processInstance = processService.handleCommand(logger, OSUtils.getHost(), this.masterExecThreadNum - activeCount, command);\n                        if (processInstance != null) {\n                            logger.info(&quot;start master exec thread , split DAG ...&quot;);\n                            // masterExecService，master执行线程 详情见 2.2\n                            masterExecService.execute(new MasterExecThread(processInstance, processService));\n                        }\n                    }catch (Exception e){\n                        logger.error(&quot;scan command error &quot;, e);\n                        processService.moveToErrorCommand(command, e.toString());\n                    }\n                } else{\n                    //indicate that no command ,sleep for 1s\n                    Thread.sleep(Constants.SLEEP_TIME_MILLIS);\n                }\n            }\n        }catch (Exception e){\n            logger.error(&quot;master scheduler thread exception&quot;,e);\n        }finally{\n            AbstractZKClient.releaseMutex(mutex);\n        }\n    }\n    logger.info(&quot;master server stopped...&quot;);\n}\n</code></pre>\n<h2>2.1. handleCommand</h2>\n<p>根据command对象构建工作流实例，构建后把该条command从t_ds_command表中删除，需要确保的是实例构建存储过程和command数据从表中删除的过程在一个事务中。</p>\n<p>command所有类型如下</p>\n<ul>\n<li>0 start a new process</li>\n<li>1 start a new process from current nodes</li>\n<li>2 recover tolerance fault process</li>\n<li>3 recover suspended process</li>\n<li>4 start process from failure task nodes</li>\n<li>5 complement data</li>\n<li>6 start a new process from scheduler</li>\n<li>7 repeat running a process</li>\n<li>8 pause a process</li>\n<li>9 stop a process</li>\n<li>10 recover waiting thread</li>\n</ul>\n<pre><code>@Transactional(rollbackFor = Exception.class)\npublic ProcessInstance handleCommand(Logger logger, String host, int validThreadNum, Command command) {\n     //根据command命令生成新的工作流程实例\n     ProcessInstance processInstance = constructProcessInstance(command, host);\n    //cannot construct process instance, return null;\n    if(processInstance == null){\n        logger.error(&quot;scan command, command parameter is error: %s&quot;, command.toString());\n        moveToErrorCommand(command, &quot;process instance is null&quot;);\n        return null;\n    }\n    if(!checkThreadNum(command, validThreadNum)){\n        logger.info(&quot;there is not enough thread for this command: {}&quot;,command.toString() );\n        return setWaitingThreadProcess(command, processInstance);\n    }\n    processInstance.setCommandType(command.getCommandType());\n    processInstance.addHistoryCmd(command.getCommandType());\n    saveProcessInstance(processInstance);\n    this.setSubProcessParam(processInstance);\n    //保存了任务流实例后将该命令删除\n    delCommandByid(command.getId());\n    return processInstance;\n}\n</code></pre>\n<h2>2.2. MasterExecThread 执行线程</h2>\n<pre><code>public void run() {\n    ......\n\n    try {\n        //检查此过程是否是补数 且 流程实例是否为子流程\n        if (processInstance.isComplementData() &amp;&amp;  Flag.NO == processInstance.getIsSubProcess()){\n            // 详情见2.2.2. 执行补数\n            executeComplementProcess();  \n        }else{\n            //详情见2.2.1. 执行流程实例\n            executeProcess(); \n        }\n    ......\n}\n</code></pre>\n<h3>2.2.1. executeProcess() 执行流程实例</h3>\n<pre><code>private void executeProcess() throws Exception {\n    //1.根据流程实例id查找有效的任务列表 initTaskQueue()\n    //2.构建DAG处理流程 buildFlowDag() 返回DAG对象，主要包括两个信息：vertex 点，即任务执行节点；edge 边，即任务之间的依赖关系\n    prepareProcess();\n    //提交并监控任务，直到工作流停止 详情见2.2.1.1\n    runProcess();\n    //当线程池不足以供流程实例使用时，创建恢复等待线程命令。\n    //子工作流程实例无需创建恢复命令。\n    //创建恢复等待线程命令并同时删除origin命令。\n   //如果存在recovery命令，则仅更新字段update_time\n    endProcess();\n}\n</code></pre>\n<h4>2.2.1.1. runProcess()提交并监控任务</h4>\n<p>submitPostNode方法传入父任务节点的名字，通过节点名，DAG，获取任务节点列表，并生成任务实例列表readyToSubmitTaskList</p>\n<pre><code>private void runProcess(){\n    submitPostNode(null);\n</code></pre>\n<p>submitStandByTask()方法里面会遍历任务实例列表readyToSubmitTaskList，判断任务实例的依赖关系，依赖项运行成功则会提交任务执行线程，失败则把当前节点状态改为失败。</p>\n<pre><code>\n       if(canSubmitTaskToQueue()){\n           submitStandByTask();\n       }\n       try {\n           Thread.sleep(Constants.SLEEP_TIME_MILLIS);\n       } catch (InterruptedException e) {\n           logger.error(e.getMessage(),e);\n       }\n       updateProcessInstanceState();\n   }\n\n   logger.info(&quot;process:{} end, state :{}&quot;, processInstance.getId(), processInstance.getState());\n}\n</code></pre>\n<p>submitStandByTask()最终会调用submitTaskExec，这里有个MasterBaseTaskExecThread线程\nMasterBaseTaskExecThread线程有两个主要作用</p>\n<ul>\n<li>用于把任务实例信息提交到数据库中submitTask()</li>\n<li>把任务信息写进Zookeeper队列 submitTaskToQueue()，后续worker会来认领任务。（节点命名方式：{processInstancePriority}_{processInstanceId}<em>{taskInstancePriority}_{taskInstanceId}</em><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi>t</mi><mi>a</mi><mi>s</mi><mi>k</mi><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>b</mi><mi>y</mi><mi>i</mi><mi>p</mi><mn>1</mn></mrow><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">{task executed by ip1},</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord textstyle uncramped\"><span class=\"mord mathit\">t</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">x</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">c</span><span class=\"mord mathit\">u</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">d</span><span class=\"mord mathit\">b</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">p</span><span class=\"mord mathrm\">1</span></span><span class=\"mpunct\">,</span></span></span></span>{ip2}...）</li>\n</ul>\n<p>另外MasterBaseTaskExecThread有两个子类，除了上面的两个作用外：</p>\n<ul>\n<li>MasterTaskExecThread 任务执行完成后会把需要kill的任务信息写入zk队列中等待worker来kill任务。</li>\n<li>SubProcessTaskExecThread 在当前工作流运行结束后会继续运行子工作流并做相关状态更新，子工作流完全完成才同步状态为子工作流的状态。</li>\n</ul>\n<p>MasterBaseTaskExecThread线程异步提交，会把结果写入activeTaskNode。</p>\n<pre><code>    private TaskInstance submitTaskExec(TaskInstance taskInstance) {\n        MasterBaseTaskExecThread abstractExecThread = null;\n        if(taskInstance.isSubProcess()){\n            abstractExecThread = new SubProcessTaskExecThread(taskInstance, processInstance);\n        }else {\n            abstractExecThread = new MasterTaskExecThread(taskInstance, processInstance);\n        }\n        Future&lt;Boolean&gt; future = taskExecService.submit(abstractExecThread);\n        activeTaskNode.putIfAbsent(abstractExecThread, future);\n        return abstractExecThread.getTaskInstance();\n    }\n</code></pre>\n<p>然后会遍历activeTaskNode，判断线程是否执行完成，若完成则移除该线程信息，再判断节点是否执行成功</p>\n<pre><code>   for(Map.Entry&lt;MasterBaseTaskExecThread,Future&lt;Boolean&gt;&gt; entry: activeTaskNode.entrySet()) {\n                Future&lt;Boolean&gt; future = entry.getValue();\n                TaskInstance task  = entry.getKey().getTaskInstance();\n\n                if(!future.isDone()){\n                    continue;\n                }\n                // node monitor thread complete\n                activeTaskNode.remove(entry.getKey());\n                if(task == null){\n                    this.taskFailedSubmit = true;\n                    continue;\n                }\n                logger.info(&quot;task :{}, id:{} complete, state is {} &quot;,\n                        task.getName(), task.getId(), task.getState().toString());\n                // 如果节点成功，则继续提交任务节点\n                if(task.getState() == ExecutionStatus.SUCCESS){\n                    completeTaskList.put(task.getName(), task);\n                    submitPostNode(task.getName());\n                    continue;\n                }\n                // 如果节点失败，先重试，然后再继续执行失败流程\n                if(task.getState().typeIsFailure()){\n                    if(task.getState() == ExecutionStatus.NEED_FAULT_TOLERANCE){\n                        this.recoverToleranceFaultTaskList.add(task);\n                    }\n                    if(task.taskCanRetry()){\n                        addTaskToStandByList(task);\n                    }else{\n                        completeTaskList.put(task.getName(), task);\n                        if( task.getTaskType().equals(TaskType.CONDITIONS.toString()) ||\n                                haveConditionsAfterNode(task.getName())) {\n                            submitPostNode(task.getName());\n                        }else{\n                            errorTaskList.put(task.getName(), task);\n                            if(processInstance.getFailureStrategy() == FailureStrategy.END){\n                                killTheOtherTasks();\n                            }\n                        }\n                    }\n                    continue;\n                }\n                // other status stop/pause\n                completeTaskList.put(task.getName(), task);\n            }\n            // send alert\n</code></pre>\n<h3>2.2.2. executeComplementProcess() 执行补数流程实例</h3>\n<pre><code>private void executeComplementProcess() throws Exception {\n....\n//根据调度的时间规则和补数的时间范围计算出需要补数的日期列表\nint processDefinitionId = processInstance.getProcessDefinitionId();\nList&lt;Schedule&gt; schedules = processService.queryReleaseSchedulerListByProcessDefinitionId(processDefinitionId);\nList&lt;Date&gt; listDate = Lists.newLinkedList();\nif(!CollectionUtils.isEmpty(schedules)){\n    for (Schedule schedule : schedules) {\n        listDate.addAll(CronUtils.getSelfFireDateList(startDate, endDate, schedule.getCrontab()));\n    }\n}\n//接下来是一个循环，用日期列表的每个日期执行一次\n//以下三个方法同 2.2.1\n....\nprepareProcess();\n....\nrunProcess();\n....\nendProcess();\n</code></pre>\n<h1>3. heartBeatThread线程</h1>\n<p>每30秒上报一次心跳信息，\n同时判断host是否在dead-servers节点下，即判断进程是否已经挂了。\n进程正常则更新Zookeeper的/dolphinscheduler/masters/${host}/ 下的节点名称，包括以下信息\nip, port ,cpUsage, memoryUsage, loadAverage, registerTIme, currentTime</p>\n<pre><code>    private Runnable heartBeatThread(){\n        logger.info(&quot;start master heart beat thread...&quot;);\n        Runnable heartBeatThread  = new Runnable() {\n            @Override\n            public void run() {\n                if(Stopper.isRunning()) {\n                    // send heartbeat to zk\n                    if (StringUtils.isBlank(zkMasterClient.getMasterZNode())) {\n                        logger.error(&quot;master send heartbeat to zk failed: can't find Zookeeper path of master server&quot;);\n                        return;\n                    }\n\n                    zkMasterClient.heartBeatForZk(zkMasterClient.getMasterZNode(), Constants.MASTER_PREFIX);\n                }\n            }\n        };\n        return heartBeatThread;\n    }\n</code></pre>\n",
  "link": "/dist/zh-cn/docs/1.2.0/user_doc/masterserver-code-analysis.html",
  "meta": {}
}